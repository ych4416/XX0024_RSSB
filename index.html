<!doctype html>
<link href="https://code.jquery.com/ui/1.9.2/themes/base/jquery-ui.css" rel="stylesheet" />
<script src="https://code.jquery.com/jquery-1.8.3.js"></script>
<script src="https://code.jquery.com/ui/1.9.2/jquery-ui.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.2.0/ace.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/eruda/1.5.4/eruda.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/peggy"></script>

<style>
    div.tabbox {
        margin: 0px;
        padding: 0px;
        width: 100%
    }

    p.tabs {
        margin: 0px;
        padding: 0px;
    }

        p.tabs a {
            display: block;
            width: 10em;
            float: left;
            margin: 0px 1px 0px 0px;
            padding: 3px;
            text-align: center;
            border-radius: 12px 12px 0px 0px; /* 角を丸くする */
        }

    #editor {
        height: 600px;
        width: 95%;
        color: lightgreen;
    }

    #svg2dgraphic {
        background-color: lavender;
    }

    button {
        height: 36pt
    }

    #saveTargetFile {
        width: 172pt;
        height: 36pt;
        font-size: 14pt;
    }

    #saveFile {
        width: 172pt;
        height: 36pt;
        font-size: 14pt;
    }

    #targetFile {
        width: 172pt;
        height: 36pt;
    }

    #outload {
        width: 95%;
        height: 600px
    }
</style>


<html lang="ja-jp">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width" />
    <title>RSSB</title>
</head>

<body>
    <h1>OISC RSSB IDE</h1>
    <div id="main-tabs">
        <ul>
            <!-- li id="tab0" ><a href="#tabs-2dgraphics">2D-GRAPHIC</a></li -->
            <li id="tab1"><a href="#tabs-main"     onclick="_switchtab(0)">MAIN</a></li>
            <li id="tab2"><a href="#tabs-editor"   onclick="_switchtab(1)">EDITOR</a></li>
            <li id="tab3"><a href="#tabs-loadsave" onclick="_switchtab(2)">LOAD/SAVE</a></li>
        </ul>
        <!-- div id="tabs-2dgraphics"><svg id="svg2dgraphic"></svg></div -->
        <div id="tabs-main"><h1>CONSOLE</h1><div id="terminal"></div></div>
        <div id="tabs-editor">
            <h1>EDITOR</h1>
            <div>
                BootStrap: <label id="bootStrapName">----</label>
                <br>
                <input type="button" id="setBootStrap" value="SET BOOTSTRAP" />
                <br>
                <select id="inBrowsing" title="FILES">
                    <!-- <option value="bootStrap" selected>bootStrap</option> -->
                </select>
                <input type="button" id="newFile" value="NEW FILE" />
                <input type="button" id="deleteFile" value="DELETE FILE" />
                <input type="button" id="renameFile" value="RENAME FILE" />
                <input type="button" id="copyFile" value="COPY FILE" />
                <input type="button" id="commitFile" value="COMMIT" />
            </div>
            <div>
                <div id="editor"></div>
            </div>
        </div>
        <div id="tabs-loadsave">
            <h1>LOAD/SAVE</h1>
            <br><input type="text" id="saveTargetFile" value="init.txt" title="Save for" />
            <a id="saveFile">Dowinload</a>
            <input type="button" id="saveToFile" value="SAVE TO FILE" />
            <br><input type="file" id="targetFile" accept=".txt" title="target" />
            <input type="button" id="loadFromFile" value="FromFile">
            <input type="button" id="toOutload" value="Parse">
            <input type="button" id="fromOutload" value="Stringify">
            <textarea id="outload" title="outload"></textarea>
        </div>
    </div>
</body>
</html>
<script>
    //
    //          UTILITIES
    //
    const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

    function RemoveAllChildren(elem) { while (elem.firstChild) { elem.removeChild(elem.firstChild); } };

    function D9(i) {
        var result = "";
        result = i < 0 ? '-' : ' ';
        var ss = Math.abs(i).toString();
        result = result + "0000000000".substring(ss.length) + ss;
        return result;
    }
</script>
<script>
    function _handleSave(content) {
        // TODO ChromeとEdge以外は保存できるかどうか試していない。
        // TODO FireFoxではsaveできてない
        if (window.File && window.FileReader && window.FileList && window.Blob) {
            // Great success! All the File APIs are supported.
        } else {
            alert('The File APIs are not fully supported in this browser.');
            return false;
        };
        var blob = new Blob([content], { "type": "text/plain" });
        var sdf = $("#saveTargetFile").val();
        var sdfn;
        if (sdf === null || sdf === undefined || sdf === "")
            sdfn = "vppl.txt";
        else
            sdfn = sdf.toLocaleString();

        //if (window.navigator.msSaveBlob) {
        //    window.navigator.msSaveBlob(blob, sdfn);
        //} else
        { // microsoft 以外のブラウザ filefoxでは動かない
            $("#saveFile").attr("href", window.URL.createObjectURL(blob));
            $("#saveFile").attr("download", sdfn);
            //        window.document.getElementById("saveFile").navigate();
            //window.alert("Save file is not supported.");
        }
        true;
    };

    function _handleLoad(filename) {
        var content = null;
        var frep;
        var mergein = false;
        if (filename === null) {
            var ldf = $("#targetFile");
            var freps = (ldf[0]).files;
            frep = freps[0];
        } else {
            frep = new File([], filename);
        };
        //uirep.StdOut("Now Loading...\n");
        try {
            var reader = new FileReader();
            reader.onload = function (e) {
                content = reader.result;
                if (content === null)
                    window.alert("読み出し結果がnull");
                else {
                    $("#outload").val(content);
                }
            };
            reader.readAsText(frep);
        } catch (e) {
            window.alert(e.toLocaleString());
        }
        ;
        return;
    };
</script>
<script>
    //
    //          TERMINAL I/O API
    //
    var term = new Terminal({
        autofocus: true, col: 80, row: 25, cursorBlink: true,
        theme: { foreground: 'lightgreen' }
    });
    term.open(document.getElementById('terminal'));
    var buffer = "";

    term.onData(function (data) {
        buffer = buffer + data;
    });

    class TerminalUI {
        constructor() { buffer = "" };
        async getch(capitalize = false) {
            while (buffer === "") {
                await sleep(10);
            }
            if (capitalize) buffer = buffer.toUpperCase();
            var result = buffer[0];
            buffer = buffer.substring(1);
            return result;
        };
        async getLine(capitalize = false) {
            var result = "";
            var ch = await this.getch(capitalize);
            while (ch !== '\r') {
                if (ch === '\x7f') {
                    if (result.length > 0) {
                        term.write('_');
                        result = result.substring(0, result.length - 1);
                    }
                }
                else {
                    term.write(ch);
                    result = result + ch;
                }
                ch = await this.getch(capitalize);
            }
            result = result + ch;
            term.write('\r\n');
            return result;
        }
        putchars(c) { term.write(c); };
        writeln(s) { term.writeln(s); };
        write(s) { term.write(s); }
        reset() { term.reset(); };
    }
</script>
<script>
    var editor = ace.edit("editor");
    editor.setTheme("ace/theme/monokai");
    //editor.session.setMode("ace/mode/javascript");
    //editor.session.setMode("ace/mode/basic");
    editor.setOptions({ fontSize: "16pt" });
    editor.$blockScrolling = Infinity;
    eruda.init();
</script>
<script>
    var _tapped = false;
    function _clickHandler(e, obj) {
        e.stopPropagation();
        if (!_tapped) {
            _tapped = true;
            sid = setTimeout(
                function () {
                    if (_tapped && obj !== null && obj.OnSingleClick !== undefined && obj.OnSingleClick !== null) { obj.OnSingleClick(e, e.offsetX, e.offsetY); }
                    _tapped = false;
                }, 350);
        } else {
            clearTimeout(sid);
            _tapped = false;
            if (obj !== null && obj.OnDoubleClick !== undefined && obj.OnDoubleClick !== null)
                obj.OnDoubleClick(e, e.offsetX, e.offsetY);
        };
    }
    /*
    var _2DObjects = [];
    const SvgRoot = $("#svg2dgraphic")[0]
    function Reset2DWorld() {
      _2DObjects = [];
      RemoveAllChildren(SvgRoot);
    }
    function Install2DObj(typ, parent, content, attrs, ud) {
      var svg = document.createElementNS('http://www.w3.org/2000/svg',typ);
      for (const key in attrs) { svg.setAttributeNS(null,key, attrs[key]); }
      if(content !== null) svg.textContent = content;
      if(parent !== null) parent.appendChild(svg);
      svg.addEventListener('click', (e) => {_clickHandler(e,ud);});
    }
    */
</script>
<script>
    //
    //   MAINLINE
    //
    var terminalUI = new TerminalUI();
    (async function commandLineLoop() {
        // Reset2DWorld();
        /* Install2DObj("text", SvgRoot, "青い TEXT",
        { "x": 10, "y": 30, "font-size": 10, "width": 50, "height": 50, "fill": "blue" },
        {
            OnSingleClick: function(e, x, y) { window.alert("SingleClick x:" + x + " y:" + y) },
            OnDoubleClick: function(e, x, y) { window.alert("DoubleClick x:" + x + " y:" + y) }
        });*/

        terminalUI.reset();
        terminalUI.writeln("WELCOME TO RSSB MONITOR");
        var cmd = "";
        while (cmd !== "quit\r") {
            await terminalUI.write("> ");
            cmd = await terminalUI.getLine();
            if (cmd === "quit\r") break;
            if (cmd === "run\r") {
                await RunProgram(editor.getValue());
                continue;
            }
            if (cmd === "debug\r") {
                await DebugProgram();
                continue;
            }
            await Monitor(cmd);
        }
        term.writeln("BYE...");
    })();
</script>
<script>
    //
    //        ARITHMETIC FORMULA API
    //
    function Postfixify(f, opo = {}) {
        var oporder = { "(": 99, ")": 99, "*": 10, "/": 10, "+": 20, "-": 20 };
        oporder = oporder.concat(opo);
        var opstack = [];
        var result = [];
        f.forEach((e) => {
            switch (e) {
                case '(': opstack.push(e); break;
                case ')':
                    do {
                        if (opstack.length <= 0) break;
                        var x = opstack.pop();
                        if (x === "(") break;
                        result = result.concat(x);
                    } while (true);
                    break;
                default:
                    if (oporder[e] === undefined)
                        result = result.concat(e);
                    else {
                        var x = null;
                        if (opstack.length === 0) { opstack.push(e); break; };
                        x = opstack[opstack.length - 1];
                        if (oporder[x] === oporder[e]) { result = result.concat(opstack.pop()); opstack.push(e); break; }
                        do {
                            if (opstack.length <= 0) break;
                            x = opstack[opstack.length - 1];
                            if (oporder[x] > oporder[e]) { break };
                            x = opstack.pop();
                            result = result.concat(x);
                        } while (true);
                        opstack.push(e);
                    }
                    break;
            }
        });
        while (opstack.length != 0) { var tt = opstack.pop(); result = result.concat(tt) };
        return result;
    }
    function ProcessFormula(form, parser, goal, lang) {
        var farray = ParseIt(form, parser, goal);
        var ffarray = FlattenArray(farray);
        return ffarray; //eval(ffarray.join(""));
    }
    function FlattenArray(a) {
        if (typeof (a) === "string") return [a];
        if (typeof (a) === "number") return [a];
        if (typeof (a) !== "object") return [];
        if (a.type !== undefined) return [a];
        if (a.length === 0) return [];
        var result = [];
        a.forEach((x) => {
            var tmp = FlattenArray(x);
            result = result.concat(tmp);
        });
        return result;
    }
    function FlattenString(val) {
        if (val === null) return "";
        if (typeof (val) === "string") return val;
        if (typeof (val) === "number") return "" + val;
        if (typeof (val) !== "object") return "";
        if (val.length === 0) return "";
        var result = "";
        val.forEach((x) => {
            var tmp = FlattenString(x);
            result += tmp;
        });
        return result;
    }
    var grammer = '\
  cmp = cmpt cmpr / cmpt \n\
  cmpr = oropsym cmpt cmpr / oropsym cmpt \n\
  cmpt = cmpfac cmptr / cmpfac \n\
  cmptr = andopsym cmpfac cmptr / andopsym cmpfac \n\
  cmpfac = frm cmpopsym frm \n\
  asgn = l:lfh dlim "=" dlim f:frm {return [l, "=", f]; }\n\
  frm = trm frmr / trm \n\
  frmr = plusopsym trm / plusopsym trm frmr\n\
  trm = fac trmr / fac \n\
  trmr = mulopsym fac trmr / mulopsym fac \n\
  fac = dlim valn:num dlim {return valn; } / "(" frm ")" / dlim vals:sfc dlim {return vals; }\n\
  num = float / integer \n\
  float = val:([+-]?[0-9]+("."[0-9]+)?([eE][+-]?[0-9]+)?) {return parseFloat(FlattenString(val)); }\n\
  integer = val:([+-]?[0-9]+) {return parseInt(FlattenString(val),10); }\n\
  lfh = ss:sym "(" idx: arg ")" { return {type: "var", sym:ss, index: idx};} / ss:sym  ("(" dlim ")")?{ return {type:"var", sym:ss, index:null}; } \n\
  sfc = str / lfh \n\
  sym = val:([a-zA-Z]+[a-zA-Z0-9]?("$")*) {return FlattenString(val);} \n\
  arg = s1:frm "," s2:arg {return FlattenArray([s1, s2]); } / s1: frm  {return [s1]; } \n\
  str = "\\"" valx:[^"]* "\\"" { return {type: "string", val: FlattenString(valx)}; } \n\
  eol = $[\\r\\n] \n\
  dlim = $[ \t]* \n\
  ';

    function ParseIt(literal, parser, goal) {
        var result = [];
        try {
            result = parser.parse(literal, { StartRule: goal });
        } catch (e) {
            ""
            console.log(e.message);
        }
        return result;
    };
</script>
<script lang="javascript">
    //
    //          RSSB - Reverse Subtract Skip if Borrow
    //
    async function RSSB(mem, start, traceFunc, getChar, putChars) {
        const pc = 0;
        const acc = 1;
        const zero = 2;

        mem[pc] = start;
        mem[zero] = 0;

        while (!(mem[pc] == 2 && mem[acc] == 1)) {
            if (pc < 0 || Number.isNaN(mem[pc])) {
                window.alert("incorrect PC value: " + ("PC=" + pc + "mem[pc]=" + mem[pc]) + ".. abort");
                return;
            }
            var addr = mem[pc];
            var op = mem[addr];
            switch (op) {
                case 3:
                    mem[op] = 0;
                    mem[op] = await getChar();
                    break;
            }
            if (op == 4) {
                mem[op] = mem[acc];
            } else {
                if ((isNaN(mem[op]) || isNaN(mem[acc])) && traceFunc !== null) await traceFunc(mem[pc]);
                var val = mem[op] - mem[acc];
                if (isNaN(val)) {
                window.alert("incorrect Sub value: " + ("PC=" + pc + "mem[pc]=" + mem[pc]+" acc="+acc) + ".. abort");
                return;
            }
                mem[acc] = val;
                mem[op] = val;
            }
            mem[pc] += mem[acc] >= 0 ? 1 : 2;
            if (op == 2) mem[op] = 0;
            if (op == 4)
                await putChars(String.fromCharCode([mem[op]]));
            if (traceFunc !== null && ! await traceFunc(mem[pc])) return;
        } // while
        terminalUI.writeln("Processor: HALTED...")
    }
</script>
<script>
    //
    //        RSSB MONITOR
    //
    var mem = new Array(1024).fill(4);
    var src = new Array(1024).fill(undefined);
    async function RunProgram(line) {
        var text = editor.getValue();
        if (Assemble(text, function (s) { terminalUI.writeln(s) }))
            await RSSB(mem, 5, function (addr) { return true; }, async function () { return await terminalUI.getChar(false) }, async function (s) { await terminalUI.putchars(s); });
        terminalUI.writeln("Rssb Halted..\r\nReady.");
    }
    async function DebugProgram() {
        _switchtab(1);
        var text = editor.getValue();
        var objs = Assemble(text, (s) => {
            terminalUI.writeln(s);
            window.alert(s);
        });
        if (objs != null && typeof (objs) === "string") {
            terminalUI.writeln("Starting Debugger...");
            storage.files['a.out'] = objs;
            ResetMenu();
            SwitchFile('a.out');
            Loader(objs);
            await Debugger(5);
            //await RSSB(mem,5,Debugger, DebugGetChar, DebugPutChars);
        }

        terminalUI.writeln("Debugger Terminated..\r\nReady.");
    }
</script>

<script>
    //
    //        RSSB CLI DEBUGGER
    //
    var breakPoints = [];
    async function DispTrace(addr, srcpos) {
        if (src[addr] !== undefined)
            await terminalUI.writeln(D9(addr) + " " + D9(mem[addr]) + " : " + src[addr].level + " " + src[addr].ss);
        else
            await terminalUI.writeln(D9(addr) + " " + D9(mem[addr]) + " : NO SOURCE ATTACHED");
        await Examine("0");
        await Examine("" + addr);
        await Examine("" + mem[addr]);
        return;
        var sp = (srcpos - 7 < 0) ? 0 : srcpos - 7;
        for (var i = sp; i < sp + 10; i++) {
            var addrk = i;
            if (src[addrk] !== undefined) await terminalUI.writeln(D9(addrk) + " " + D9(mem[addrk]) + " : " + src[addrk].level + " " + src[addrk].ss);
        }
    }
    async function Debugger(addr) {
        await terminalUI.write("# ");
        var cmd = await terminalUI.getLine(false);
        while (cmd !== "exit\r") {
            if (cmd === "s\r") {
                await RSSB(mem, addr, async function (addrz) {
                    await DispTrace(addrz, addrz);
                    addr = addrz;
                    return false;
                }, DebugGetChar, DebugPutChars);
            }
            else if (cmd === "n\r") {
                lvl = (src[addr] !== undefined && src[addr].level !== undefined) ? src[addr].level : 0;
                await RSSB(mem, addr, async function (addrz) {
                    if (src[addrz] !== undefined && src[addrz].level !== undefined && src[addrz].level > lvl) return true;
                    await DispTrace(addrz, addrz);
                    addr = addrz;
                    return false;
                }, DebugGetChar, DebugPutChars);
            }
            else if (cmd === "u\r") {
                lvl = (src[addr] !== undefined && src[addr].level !== undefined) ? src[addr].level : 0;
                if (lvl <= 0) return false;
                await RSSB(mem, addr, async function (addrz) {
                    if (src[addrz] !== undefined && src[addrz].level !== undefined && src[addrz].level > lvl - 1) return true;
                    await DispTrace(addrz, addrz);
                    addr = addrz;
                    return false;
                }, DebugGetChar, DebugPutChars);
            }
            else if (cmd === "cont\r") {
                var naddr = addr;
                await RSSB(mem, addr, async function (addr) {
                    if (breakPoints.includes(addr)) {
                        terminalUI.writeln("Break stop at : " + addr);
                        await DispTrace(addr, addr);
                        naddr = addr; return false;
                    } else
                        return true;
                }, async function () { return await terminalUI.getch(false) }, async function (c) { await terminalUI.write(c); });
                addr = naddr;
            }
            else if (cmd.substring(0, 3) === "abp") {
                var addr0 = Number.parseInt(cmd.substring(3));
                if (isNaN(addr0)) { terminalUI.writeln("add bp : addr? => " + cmd.substring(3)); continue; }
                var id = breakPoints.indexOf(addr0);
                if (id < 0) id = breakPoints.indexOf(-addr0);
                if (id >= 0) breakPoints[id] = Math.abs(breakPoints[addr0]);
                else
                    breakPoints.push(addr0);
            } else if (cmd === "cbp\r")
                breakPoints = [];
            else if (cmd.substring(0, 3) === "tbp") {
                var addr1 = Number.parseInt(cmd.substring(3));
                if (isNaN(addr1)) { terminalUI.writeln("toggle bp : addr? => " + cmd.substring(3)); continue; }
                var id = breakPoints.indexOf(addr1);
                if (id < 0) id = breakPoints.indexOf(-addr1);
                if (id >= 0) breakPoints[id] = -breakPoints[id];
                else
                    breakPoints.push(-addr1);
            } else if (cmd === "lbp\r") {
                terminalUI.writeln("List bps: " + breakPoints);
            } else if (cmd.substring(0, 2) === "ex" || cmd.substring(0, 2) === "dp")
                await Monitor(cmd);
            else
                terminalUI.writeln(cmd.substring(0, cmd.length - 1) + "-> ????");
            await terminalUI.write("# ");
            cmd = await terminalUI.getLine(false);
        }
    }
    async function DebugGetChar() {
        termialUI.writeln("GETCHAR In Debug : ");
        var ch = await terminalUI.getChar(false);
        terminalUI.writeln("");
    }
    function DebugPutChars(s) { terminalUI.writeln("PUTCHAR in Debug : " + s); }
</script>
<script>
    function ToNextBlank(line) {
        var result = 0;
        while (result <= line.length && " \t\r\n".IndexOf(line[resutl]) < 0) result++;
        return result;
    }
    async function Monitor(cmd) {
        if (cmd.substring(0, 3) === "ex ") await Examine(cmd.substring(3));
        else if (cmd.substring(0, 3) === "dp ") await Deposite(cmd.substring(3));
        else terminalUI.writeln("->" + cmd.substring(0, cmd.length - 1) + " -> ???");
        return true;
    }
    async function Examine(parmstr) {
        var parms = parmstr.split(",");
        var bp = Number.parseInt(parms[0]);
        if (Number.isNaN(bp)) return;
        var ep = (parms[1] !== null) ? Number.parseInt(parms[1]) : bp + 10;
        if (Number.isNaN(ep)) ep = bp + 10;
        ep = Math.min(ep, mem.length);
        for (var i = bp; i < ep; i++) {
            if ((i - bp) % 5 == 0) terminalUI.write("" + D9(i) + " : ");
            terminalUI.write(" " + D9(mem[i]));
            if ((i - bp) % 5 == 4) terminalUI.writeln("");
        };
        terminalUI.writeln("");
        return true;
    }
    async function Deposite(parmstr) {
        var parms = parmstr.split(",");
        var bp = Number.parseInt(parms[0]);
        if (Number.isNaN(bp)) reutrn;
        var ep = (Number.isNaN(parseInt(parms[1]))) ? bp + 10 : parseInt(parms[1]);
        ep = Math.min(ep, mem.length);
        while (bp < ep) {
            terminalUI.write("" + D9(bp) + " " + D9(mem[bp]) + " : ");
            var v = await terminalUI.getLine();
            if (v === "\r") {
                bp++
                continue;
            }
            var vv = Number.parseInt(v);
            if (!Number.isNaN(vv)) {
                mem[bp] = vv;
                bp++
                continue;
            }
            break;
        }
        return true;
    }
</script>
<script>
    //
    // FILE SYSTEM
    //
    var storage = {
        bootStrap: "AAA",
        files: {
            "AAA": "UNDER CONSTRUCTION\n AAAA\n",
            "JJJ": "UNDER CONSTRUCTION\n JJJJ\n"
        }
    };

    var curFileName = null;

    function ResetMenu() {
        RemoveAllChildren($("#inBrowsing")[0]);
        var fnames = []
        for (const key in storage.files) {
            fnames.push(key);
        }
        fnames.sort();
        for (const key in fnames) {
            $("#inBrowsing").append(new Option(fnames[key], fnames[key]));
        };
        $('#bootStrapName')[0].innerHTML = storage.bootStrap;
        SwitchFile(storage.bootStrap);
    }

    function SwitchFile(newFileName) {
        if (newFileName === null) return;
        if (storage.files[newFileName] === undefined) return;
        for (var i = 0; i < Object.keys(storage.files).length; i++) {
            if ($("#inBrowsing")[0].options[i].value === newFileName)
                $('#inBrowsing')[0].options[i].selected = true;
        }
        //if (curFileName !== null && storage.files[curFileName] !== undefined) {
        //    storage.files[curFileName] = editor.getValue();
        //}
        editor.setValue(storage.files[newFileName]);
        editor.selection.clearSelection();
        curFileName = newFileName;
    }

    function NewFileHandler(e) {
        var newFileName = window.prompt("Enter New File Name.");
        if (newFileName === null) return;
        if (storage.files[newFileName] !== undefined) {
            if (!windows.confirm("" + newFileName + " is already exists. Overwrite?")) return;
        }
        storage.files[newFileName] = "";
        ResetMenu();
        SwitchFile(newFileName);
    }

    function RenameFileeHandler(e) {
        var newFileName = window.prompt("Enter New File Name.");
        var curFileName = $("#inBrowsing")[0].options[$("#inBrowsing")[0].selectedIndex].value;

        if (newFileName === null) return;
        if (storage.files[newFileName] !== undefined) {
            if (!windows.confirm("" + newFileName + " is already exists. Overwrite?")) return;
        }
        storage.files[newFileName] = storage.files[curFileName];
        delete storage.files[curFileName];
        if (storage.bootStrap === curFileName) storage.bootStrap = newFileName;
        ResetMenu();
        SwitchFile(newFileName);
    }

    function SetBootStrapHandler(e) {
        var curFileName = $("#inBrowsing")[0].options[$("#inBrowsing")[0].selectedIndex].value;
        storage.bootStrap = curFileName;
        ResetMenu();
        SwitchFile(curFileName);
    }

    function DeleteFileHandler(e) {
        if (!window.confirm("OK to delete current file?")) return;
        var curFileName = $("#inBrowsing")[0].options[$("#inBrowsing")[0].selectedIndex].value;
        if (storage.files[curFileName] === undefined) {
            window.alert("" + curFileName + " Does not exists.");
            return;
        }

        delete storage.files[curFileName];

        if (storage.bootStrap === curFileName) {
            storage.bootStrap = Object.entries(storage.files)[0][0];
        }
        ResetMenu();
        SwitchFile(storage.bootStrap);
    }

    function CopyFileHandler(e) {
        var newFileName = window.prompt("Enter New File Name to Copy.");
        if (newFileName === null) return;
        if (storage.files[newFileName] !== undefined) {
            if (!windows.confirm("" + newFileName + " is already exists. Overwrite?")) return;
        }
        storage.files[newFileName] = editor.getValue();
        ResetMenu();
        SwitchFile(newFileName);
    }

    function RemoveCR(src) {
        var dst = "";
        for (var i = 0; i < src.length; i++) {
            if (src[i] !== '\r') dst += src[i];
        };
        return dst;
    }

    function CommitFileHandler(e) {
        storage.files[$("#inBrowsing").val()] = RemoveCR(editor.getValue());
    }

    (function () {
        $("#inBrowsing")[0].addEventListener('change', (e) => {
            SwitchFile($('#inBrowsing').val());
        })

        $("#loadFromFile")[0].addEventListener('click', (e) => { _handleLoad(null); });
        $('#saveToFile')[0].addEventListener('click', (e) => { _handleSave($("#outload").val()) });
        $("#fromOutload")[0].addEventListener('click', (e) => { $("#outload").val(JSON.stringify(storage)) });
        $('#toOutload')[0].addEventListener('click', (e) => {
            storage = JSON.parse($("#outload").val());
            ResetMenu();
        });
        $('#setBootStrap')[0].addEventListener('click', (e) => { SetBootStrapHandler(e); });
        $('#newFile')[0].addEventListener('click', (e) => { NewFileHandler(e); });
        $('#deleteFile')[0].addEventListener('click', (e) => { DeleteFileHandler(e) });
        $('#renameFile')[0].addEventListener('click', (e) => { RenameFileHandler(e) });
        $('#copyFile')[0].addEventListener('click', (e) => { CopyFileHandler(e) });
        $('#commitFile')[0].addEventListener('click', (e) => { CommitFileHandler(e); });
        ResetMenu();
    })();
</script>
<script>
    //
    //          MACRO ASSEMBLER
    //

    var lines = [];  // of string of Source line.

    var mAsemGrammer = ' \n\
   masmFile = ff:line* {return ff ;} \n\
   line = dlims ss:eol / ss:statement eol / ss:statement !. / ss:eol {return ss;}\n\
   statement = comment / labeled / includes / unlabeled\n\
   comment = dlim* ";" ss:$([^\\n])* { return {type: "comment", val:ss}; }\n\
   includes = "#include" dlim* ifile:$([^\\n])* {return {type: "include", filename: ifile};} \n\
   instruction = labeled / unlabeled\n\
   labeled = sym:symbol dlims op:symbol oprs:(opr)* dlim* cmt:comment? {return {type: "instruction", label: sym, op: op, oprs:oprs, comment:cmt};} \n\
   unlabeled = dlims op:symbol oprs:(opr)* dlim* cmt:comment? {return {type: "instruction", label: null, op: op, oprs:oprs, comment:cmt};} \n\
   dlim = $[ ,\t] \n\
   dlims = $[ ,\t]+ \n\
   eol = $("\\r\\n") / $("\\n") \n\
   opr = dlims oprstr:$((([a-zA-Z0-9] / "+" / "-" / "*" / "/" / "(" / ")" / ">" / "<" / "=" / "?" / "!" / ":" )+) / "\'" ([^\'])* "\'") {var val = parseInt(oprstr); return Number.isNaN(val)?oprstr:val; }\n\
   symbol = sym:$([a-zA-Z][0-9a-zA-Z]*) {return sym;}\n\
   ';
    class SymTab {
        tbl = { "PC": { val: 0, len: 1 }, "ACC": { val: 1, len: 1 }, "ZERO": { val: 2, len: 1 }, "CIN": { val: 3, len: 1 }, "COUT": { val: 4, len: 1 } };
        parent = null;
        constructor(parent) { this.parent = parent; }
        SetVal(key, val) { this.tbl[key] = { val: val, len: 1 }; }
        Find(key) {
            if (this.tbl[key] !== undefined) {
                var kval = this.tbl[key].val;
                if (typeof (kval) === 'number') return kval;
                //f(key!==kval)
                //  return this.Find(kval);
                //else
                return this.parent.Find(kval);
            }
            if (this.parent === null || this.parent === undefined) return undefined;
            return this.parent.Find(key);
        }
    }

    function Pass0_Read(inputText, errorFunc, included) {
        var result = null;
        try {
            var parser = peggy.generate(mAsemGrammer);
            result = ParseIt(inputText, parser, "masmFile");
            if (result === undefined) result = { type: "UNDEFINED" };
            if (result === null || result.length <= 0) { result = null; return null; };
        } catch (e) { errorFunc(e.message); result = null; return null; }
        lines = [];
        result.forEach((l) => {
            if (typeof (l) !== "object") return null;
            if (l[0] === undefined)
                s = l;
            else
                s = l[0]
            if (s.type === undefined) return null;
            if (s.type === "comment") { lines.push(s); return null };
            if (s.type === "include") { if (Pass0_Include(s.filename, errorFunc, included) == null) return; }
            else
                lines.push(s);
        })
        return lines;
    }

    function Pass0_Include(ifilename, errorFunc, includelist) {
        if (includelist[ifilename] !== undefined) { return lines; }; // already included - skip without warnings
        var incltxt = storage.files[ifilename];
        if (incltxt === undefined) { errorFunc("INVALID INCLUDE - NOT FOUND : \"" + ifilename + "\""); return null; };
        includelist[ifilename] = true;
        return Pass0_Read(incltxt, errorFunc, includelist);
    }

    var macrotbl = [];
    function Pass1_CollectMacro(errorFunc) {
        var inMacro = false;
        var macroName = null;
        for (var i = 0; i < lines.length; i++) {
            var l = lines[i];
            if (l.op === "DEFMACRO") {
                if (inMacro) { errorFunc("DEFMACRO is nested"); return false; };
                macroName = l.label; if (l.label === null) { errorFunc("NO NAME DEFMACRO"); return false; };
                inMacro = true;
                macrotbl[macroName] = { startline: i, endline: null, oprs: l.oprs };
            } else if (l.op === "ENDMACRO") {
                if (!inMacro) { errorFunc("INVALID ENDMACRO : NO DEFMACRO COUNTERPART"); return false; };
                macrotbl[macroName].endline = i;
                macroName = null;
                inMacro = false;
            }
        }
        return true;
    }


    var mSymTab = [];
    var objs = []; // of {addr: number, code: numer | formula} || {lvl: level, tab: Symtab};
    var exports = []; // of string;
    var memlength = 1024;

    function tokenizeExpression(expression) {
        const tokens = [];
        const regex = /\w+(\.\w+)?|[+\-*/()<>!?:]/g;
        let match;

        while ((match = regex.exec(expression)) !== null) {
            tokens.push(match[0]);
        }

        return tokens;
    }

    function ResolveFormula(form, symTab, errorFunc) {
        var sv = symTab.Find(form);
        if (sv !== undefined) return sv;
        var v = Number.NaN;
        try { v = eval(form) } catch (e) { return v; };
        if (!Number.isNaN(v)) return v;

        var tmp = "";
        var terms = [];
        var rest = form;
        if (form[0] === "\"" || form[0] === "'") tmp = from;
        else {
            terms = tokenizeExpression(form);
            if (terms.length <= 1) return form;
            for (var i = 0; i < terms.length; i++)
                switch (terms[i]) {
                    case "\"": case "'": case "+": case "-": case "*": case "/": case "(": case ")": case "<": case ">": case "!": case "?": case ":":
                        tmp = tmp + terms[i];
                        break;
                    default:
                        var syms = ResolveFormula(terms[i], symTab, errorFunc);
                        if (syms === undefined) {
                            errorFunc("Formula have unsolved symbol : " + terms[i]);
                            return null;
                        }
                        tmp = tmp + " " + syms;
                        break;
                }
            return tmp;
        }

        var zz = null;
        try { zz = eval(tmp); } catch (e) { errorFunc("malformd : " + form); return null; };
        if (typeof (zz) !== "string") zz = [zz];
        return zz;
    }

    function EvalFormula(form, symTab, errorFunc) {
        var v = Number.NaN;
        try { v = eval(form) } catch (e) { };
        if (!Number.isNaN(v)) return v;
        var tmp = "";
        var terms = [];
        var rest = form;
        if (form[0] === "\"" || form[0] === "'") tmp = from;
        else {
            terms = tokenizeExpression(form);
            for (var i = 0; i < terms.length; i++)
                switch (terms[i]) {
                    case "\"": case "'": case "+": case "-": case "*": case "/": case "(": case ")": case "<": case ">": case "!": case "?": case ":":
                        tmp = tmp + terms[i];
                        break;
                    default:
                        var syms = !Number.isNaN(parseInt(terms[i])) ? parseInt(terms[i]) : symTab.Find(terms[i]);
                        while (syms !== undefined && typeof (syms) !== "number") {
                            syms = EvalFormula(syms.val, symTab, errorFunc);
                        }
                        if (syms === undefined) {
                            errorFunc("Formula have unsolved symbol : " + terms[i]);
                            return null;
                        }
                        tmp = tmp + " " + syms;
                        break;
                }
            var result = null;
            try { result = eval(tmp) } catch (e) { errorFunc("Malformed : " + form); return null };
            return result;
        }

        var zz = null;
        try { zz = eval(tmp); } catch (e) { errorFunc("malformd : " + form); return null; };
        if (typeof (zz) !== "string") zz = [zz];
        return zz;
    }

    function Pass2_CodeGen(addr, lines, pgm, errorFunc, symTab, expMacro, lvl, prefix) {
        var inMacro = false;
        var stab = new SymTab(symTab);
        objs.push({ lvl: lvl, tab: stab })
        for (var i = 0; i < lines.length; i++) {
            var l = lines[i];
            if (l.type === "comment" && !inMacro) {
                objs.push({ type: "comment", val: l.val });
                continue;
            }
            if (inMacro && l.op === "ENDMACRO") { inMacro = false; continue; };
            if (inMacro) continue;
            if (l.op === "DEFMACRO") { inMacro = true; continue; };
            if (l.label !== null) stab.SetVal(l.label, addr);
            switch (l.op) {
                case "MEMORY":
                    if (expMacro) { errorFunc("MEMORY is inValid in Macro Defs"); return; };
                    var val = Number.NaN;
                    var src = l.oprs[0];
                    if (typeof (src) === "number") memlength = src;
                    else if ((src = stab.Find(src)) !== undefined && !Number.isNaN(val = parseInt(src))) {
                        memlength = val;
                    } else {
                        errorFunc("Invalid Parm of MEMORY"); return;
                    };
                    break;
                case "EXPORT":
                    if (l.opr.length <= 0) { errorFunc("EXPORT needs a operand"); return; };
                    if (l.opr[0].length <= 0) { errorFunc("EXPORT needs a non-empty operand"); };

                    exports.push(l.opr[0]);
                    break;
                case "ORG":
                    if (expMacro) { errorFunc("ORG is inValid in Macro Defs"); return; };
                    var val = Number.NaN;
                    if (l.oprs[0] !== undefined && !Number.isNaN(val = parseInt(l.oprs[0]))) {
                        addr = val;
                    } else {
                        errorFunc("Parm is ORG is not Number"); return;
                    };
                    break;
                case "DEF":
                    if (l.label === null) { errorFunc("DEF without Label"); reutrn; }
                    if (l.oprs.length <= 0) { errorFunc("DEF needs a operand"); return; };
                    stab.SetVal(l.label, l.oprs[0]);
                    break;
                case "DC":
                    if (l.oprs.length <= 0) { errorFunc("DC needs a operand"); return; };
                    if (l.oprs[0].length <= 0) { errorFunc("DC needs a non-empty operand"); };
                    var src = "" + lvl + " " + prefix + ": ";
                    src = src + ((l.label !== undefined && l.label !== null) ? l.label + " " : "\t\t") + l.op;
                    if (l.oprs !== undefined) { for (var m = 0; m < l.oprs.length; m++) { src += " " + l.oprs[m] } };
                    if (l.comment !== undefined && l.comment !== null && l.comment.val !== undefined) src += "\t;" + l.comment.val;
                    for(var mm=0; mm < l.oprs.length; mm++){
                        var ss = null;
                        try{ss = eval(l.oprs[mm])}catch(e){};
                        if(typeof(ss) === "string"){
                            for (var i2 = 0; i2 < ss.length; i2++) {
                                objs.push({ addr: addr, val: (ss.charCodeAt(i2)), src: src + " " + i2 + " of " + ss.length });
                                addr++;
                            };
                        } else {
                            objs.push({ addr: addr, val: l.oprs[mm], src: src });
                            addr++;
                        }
                    };
                    break;
                case "DCS":
                    if (l.oprs.length <= 0) { errorFunc("DCS needs a operand"); return; };
                    if (l.oprs[0].length <= 0) { errorFunc("DCS needs a non-empty operand"); return; };
                    var xx = null;
                    try { xx = eval(l.oprs[0]); } catch (e) { errorFunc("DCS : malformed constant"); return; };
                    if (typeof (xx) !== "string") { errorFunc("DCS needs a string constant"); return; };

                    var src = "" + lvl + " " + prefix + ": ";
                    src = src + ((l.label !== undefined && l.label !== null) ? l.label + " " : "\t\t") + l.op;
                    for (var i2 = 0; i2 < xx.length; i2++) {
                        objs.push({ addr: addr, val: (xx.charCodeAt(i2)), src: src + " " + i2 + " of " + xx.length });
                        addr++;
                    };
                    break;
                case "DS":
                    if (l.oprs.length <= 0) { errorFunc("DS needs a operand"); return; };
                    if (l.oprs[0].length <= 0) { errorFunc("DS needs a non-empty operand"); };
                    var v = parseInt(l.oprs[0]);
                    if (Number.isNaN(v)) { errorFunc("DS needs a integer operand"); return; };
                    if (v <= 0) { errorFunc("DS needs a positive integer operand"); return; };
                    var src = "" + lvl + " " + prefix + ": ";
                    src = src + ((l.label !== undefined && l.label !== null) ? l.label + " " : "\t\t") + l.op;
                    //for(var i2=0; i2<v; i2++) {
                    //  objs.push({addr:addr, val: 78, src: src+" "+i2+" of "+v});
                    //  addr++;
                    //};
                    addr += v
                    break;
                case "RSSB":
                    if (l.oprs.length <= 0) { errorFunc("RSSB needs a operand"); return; };
                    var src = "" + lvl + " " + prefix + " : ";
                    src = src + ((l.label !== undefined && l.label !== null) ? l.label + " " : "\t\t") + l.op;
                    if (l.oprs !== undefined) { for (var m = 0; m < l.oprs.length; m++) { src += " " + l.oprs[m] } };
                    if (l.comment !== undefined && l.comment !== null && l.comment.val !== undefined) src += "\t;" + l.comment.val;
                    objs.push({ addr: addr, val: l.oprs[0], src: src });
                    addr++;
                    break;
                default:
                    if (macrotbl[l.op] !== undefined) {
                        var mcr = macrotbl[l.op];
                        var body = [];
                        var newSymTab = new SymTab(stab);
                        for (var j = 0; j < l.oprs.length; j++) {
                            if (l.oprs[j] === undefined) { errorFunc("MACRO opr number is mismatch."); { return }; };
                            newSymTab.SetVal(mcr.oprs[j], l.oprs[j]);
                        }
                        for (var k = mcr.startline + 1, j = 0; k <= mcr.endline - 1; k++, j++) {
                            body[j] = pgm[k];
                        }
                        addr = Pass2_CodeGen(addr, body, pgm, errorFunc, newSymTab, true, lvl + 1, prefix + ":" + l.op);
                        if (addr === undefined || addr === null) { return; };
                        objs.push({ lvl: lvl, tab: stab }); // revert symtab
                    } else {
                        errorFunc("Unknown OP : " + l.op); return;
                    }
                    break;
            }
        };
        return addr;
    }

    function Pass3_ResolveSymbols(errorFunc, evalFormula) {
        var stab = objs[0].tab;
        for (var i = 0; i < objs.length; i++) {
            var ss = objs[i];
            if (ss.type === "comment") continue;
            if (ss.lvl !== undefined) { stab = ss.tab; continue; }; // skip syntab entry
            var v = evalFormula ? EvalFormula(ss.val, stab, errorFunc) : ResolveFormula(ss.val, stab, errorFunc);
            if (v === undefined || v === null || isNaN(v)) {
                errorFunc("Error On: " + ss.src);
                return false;
            };
            ss.val = v;
        };
        return true;
    }

    function Pass4_Emit(errorFunc) {
        var result = "";
        var symTab = objs[0].tab;
        result = result + "MEMORY " + memlength + "\n"
        for (var i = 0; i < exports.length; i++) {
            var v = EvalFormula(exports[i], symTab, errorFunc);
            if (v === undefined || v === null || typeof (v) !== "bigint") { errorFunc("EMIT : invlid EXPORT OPERAND"); return falese; };
            result = result + "EXPORT " + exports[i] + " " + v + "\n";
        }
        for (var i = 0; i < objs.length; i++) {
            var l = objs[i];
            if (l.type === "comment") { result += "; " + l.val + "\n"; continue; };
            if (l.lvl !== undefined) continue;
            if (typeof (l.val) !== "number") { errorFunc("CODEGEN : fourmula still remains : " + l.val); return false; };
            result = result + D9(l.addr) + " " + D9(l.val) + ((l.src !== undefined) ? " ; " + l.src : "") + "\n";
        }
        return result;
    }

    function Assemble(text, errorFunc) {
        objs = [];
        lines = [];
        if (Pass0_Read(text, errorFunc, {}) === null) return null;
        if (!Pass1_CollectMacro(errorFunc)) return null;
        var result = Pass2_CodeGen(0, lines, lines, errorFunc, null, false, 0, "");
        if (result === undefined || result === null) return null;
        if (!Pass3_ResolveSymbols(errorFunc, true)) return null;
        return Pass4_Emit(errorFunc);
    }

    function InitialLoad() {
        var initialscript = "./init.txt";
        var request = new XMLHttpRequest();
        request.addEventListener("load", function (e) {
            var _initialscriptstring = request.responseText;
            if (_initialscriptstring === "") {
                _initialscriptstring = null;
                window.alert("Failing initial loading..");
            } else {
                $("#outload").val(_initialscriptstring);
                storage = JSON.parse($("#outload").val());
                ResetMenu();
                SwitchFile(storage.bootStrap);
            }
        });
        request.addEventListener("error", function (e) {
            window.alert("Failing initial loading..");
        });
        request.addEventListener("abort", function (e) {
            window.alert("abort")
        });
        request.open("GET", initialscript);
        request.send();
    }

    (function () {
        InitialLoad();
    })()
</script>
<script>
    //
    //          LOADER
    //
    var objFileGrammer = ' \n\
   masmFile = ff:line* {return ff;}\n\
   line = exportLine / memsizeLine / dataLine / commentLine \n\
   exportLine = "EXPORT" dlims symbol dlims number eol\n\
   memsizeLine = "MEMORY" dlims msize:number eol { mem.length = msize; mem.fill(4); };\n\
   dataLine = dlim addr:number dlims data:number cmt:commentD? eol { mem[addr] = data; src[addr]=cmt; }\n\
   commentLine = dlim ";" $[^\\n]* eol \n\
   comment = dlim ";" ss:$[^\\n]* {return ss;}\n\
   commentD = dlim "; " lvl:number " " ss:$[^\\n]* {return {level: lvl, ss:ss};}\n\
   dlim = $[ \t]* \n\
   dlims = $[ \t]+ \n\
   eol = $[\\r\\n] \n\
   number = num:$([+-]?[0-9]+) { return parseInt(num); } \n\
   symbol = sym:$([a-zA-Z][0-9a-zA-Z]*) {return sym;}\n\
   ';
    function Loader(objFile) {
        var ram = mem;
        try {
            var parser = peggy.generate(objFileGrammer);
            result = ParseIt(objFile, parser);
            if (result === undefined) result = { type: "UNDEFINED" };
        } catch (e) { console.log(e.message); return -1; }
        return 5;
    }
</script>

<script>
    var nsave = 0;
    $(function () {
        $("#main-tabs").tabs({ active: 0 });
        nsave = 0;
    });
    function _switchtab(n) {
        $("#main-tabs").tabs({ active: n });
        if (n === 1) {
            if(nsave === 2) {
                //window.alert("AUTO LOADING...");
                //storage = JSON.parse($("#outload").val());
                ResetMenu();
            }
            editor.resize(); // refresh editor;
        } else if (n === 2) {
            if (nsave === 1) {
                //window.alert("AUTO STRINGIFY...");
                //$("#outload").val(JSON.stringify(storage));
            }
        }
        nsave = n;
    }
</script>
